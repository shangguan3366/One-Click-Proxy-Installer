#!/bin/bash
# ====================================================
# 一键梭哈脚本 · v4.0 Integrated (2026)
# 融合特性：Systemd自启 + 多语言 + 快捷菜单 + 完整节点输出
# ====================================================

set -euo pipefail

# ---------- 基础变量 ----------
BASE_DIR="${HOME}/.suoha"
BIN_DIR="$BASE_DIR/bin"
LOG_DIR="$BASE_DIR/logs"
STATE_DIR="$BASE_DIR/state"

XRAY_BIN="$BIN_DIR/xray"
ARGO_BIN="$BIN_DIR/cloudflared"

CONFIG_FILE="$BASE_DIR/config.json"
TUNNEL_CONFIG="$BASE_DIR/tunnel.yml"

XRAY_LOG="$LOG_DIR/xray.log"
ARGO_LOG="$LOG_DIR/argo.log"
LANG_FILE="$BASE_DIR/language"
LINK_FILE="$BASE_DIR/links.txt"

# 确保目录存在
mkdir -p "$BIN_DIR" "$LOG_DIR" "$STATE_DIR"

# ---------- 颜色函数 ----------
red() { echo -e "\033[31m$1\033[0m"; }
green() { echo -e "\033[32m$1\033[0m"; }
yellow() { echo -e "\033[33m$1\033[0m"; }
blue() { echo -e "\033[36m$1\033[0m"; }

# ---------- 多语言支持 ----------
declare -A zh=(
  [welcome]="===== 一键梭哈 (v4.0 增强版) ====="
  [menu_title]="当前状态管理"
  [status_running]="运行中"
  [status_stopped]="未运行"
  [menu_opt_1]="安装/重置 临时隧道 (TryCloudflare)"
  [menu_opt_2]="安装/重置 固定隧道 (自定义域名)"
  [menu_opt_3]="查看节点链接"
  [menu_opt_4]="停止服务 & 清理"
  [menu_opt_5]="切换协议 (当前: %s)"
  [menu_exit]="退出脚本"
  [lang_prompt]="请选择语言 (1=中文 / 2=English): "
  [installing]="正在安装依赖..."
  [downloading]="正在下载核心组件..."
  [generating]="正在生成配置..."
  [starting]="正在启动服务..."
  [links_saved]="节点信息已保存至: "
  [shortcut_created]="快捷指令已创建！以后输入 'suoha' 即可管理。"
  [tunnel_login]="请在浏览器打开下方链接进行授权 (Cloudflare):"
  [input_domain]="请输入绑定的完整域名 (例如: vpn.example.com): "
  [service_installed]="Systemd 服务已安装并设置为开机自启。"
)

declare -A en=(
  [welcome]="===== Suoha One-Click (v4.0 Integrated) ====="
  [menu_title]="Current Status"
  [status_running]="Running"
  [status_stopped]="Stopped"
  [menu_opt_1]="Install/Reset Quick Tunnel"
  [menu_opt_2]="Install/Reset Fixed Tunnel"
  [menu_opt_3]="View Node Links"
  [menu_opt_4]="Stop Service & Cleanup"
  [menu_opt_5]="Toggle Protocol (Current: %s)"
  [menu_exit]="Exit"
  [lang_prompt]="Select language (1=Chinese / 2=English): "
  [installing]="Installing dependencies..."
  [downloading]="Downloading core binaries..."
  [generating]="Generating configuration..."
  [starting]="Starting services..."
  [links_saved]="Links saved to: "
  [shortcut_created]="Shortcut created! Type 'suoha' to manage later."
  [tunnel_login]="Please authorize via the link below:"
  [input_domain]="Enter full domain (e.g., vpn.example.com): "
  [service_installed]="Systemd service installed and enabled."
)

# 语言初始化
if [[ ! -f "$LANG_FILE" ]]; then
  echo -e "${zh[lang_prompt]}\n${en[lang_prompt]}"
  read -p "> " l
  [[ "$l" == "1" ]] && echo zh >"$LANG_FILE" || echo en >"$LANG_FILE"
fi
LANGUAGE=$(cat "$LANG_FILE")
t(){ 
    local key=$1
    local val=""
    if [[ "$LANGUAGE" == "zh" ]]; then val="${zh[$key]}"; else val="${en[$key]}"; fi
    # 支持格式化参数
    if [[ $# -gt 1 ]]; then printf "$val" "${@:2}"; else echo "$val"; fi
}

# ---------- 状态管理 (持久化) ----------
save_state() { echo "$2" > "$STATE_DIR/$1"; }
load_state() { if [[ -f "$STATE_DIR/$1" ]]; then cat "$STATE_DIR/$1"; else echo ""; fi; }

# ---------- 核心工具 ----------
install_deps() {
    if ! command -v curl &>/dev/null || ! command -v unzip &>/dev/null || ! command -v jq &>/dev/null; then
        yellow "$(t installing)"
        if command -v apt &>/dev/null; then apt update && apt install -y curl unzip jq
        elif command -v dnf &>/dev/null; then dnf install -y curl unzip jq
        elif command -v apk &>/dev/null; then apk add curl unzip jq bash
        fi
    fi
    
    # 创建快捷指令
    if [[ ! -f "/usr/bin/suoha" ]]; then
        cat > "/usr/bin/suoha" <<EOF
#!/bin/bash
bash $0 "\$@"
EOF
        chmod +x "/usr/bin/suoha"
        green "$(t shortcut_created)"
    fi
}

download_bins() {
    if [[ -x "$XRAY_BIN" && -x "$ARGO_BIN" ]]; then return; fi
    yellow "$(t downloading)"
    
    ARCH=$(uname -m)
    case "$ARCH" in
        x86_64|amd64) xray_file="Xray-linux-64.zip"; argo_arch="amd64" ;;
        aarch64|arm64) xray_file="Xray-linux-arm64-v8a.zip"; argo_arch="arm64" ;;
        *) red "Unsupported Arch"; exit 1 ;;
    esac

    # 下载 Xray
    curl -L "https://github.com/XTLS/Xray-core/releases/latest/download/$xray_file" -o xray.zip
    unzip -o xray.zip xray -d "$BIN_DIR"
    rm -f xray.zip
    chmod +x "$XRAY_BIN"

    # 下载 Argo
    curl -L "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-$argo_arch" -o "$ARGO_BIN"
    chmod +x "$ARGO_BIN"
}

get_isp() {
    curl -s --max-time 3 https://speed.cloudflare.com/meta | jq -r '"\(.city)-\(.colo)-\(.asn)"' 2>/dev/null || echo "Unknown"
}

# ---------- 生成配置 ----------
gen_config() {
    local protocol=$1
    # 读取或生成配置
    UUID=$(load_state "uuid")
    [[ -z "$UUID" ]] && UUID=$(cat /proc/sys/kernel/random/uuid || uuidgen) && save_state "uuid" "$UUID"
    
    PORT=$(load_state "port")
    [[ -z "$PORT" ]] && PORT=$((RANDOM % 10000 + 10000)) && save_state "port" "$PORT"
    
    PATH_ID=$(load_state "path")
    [[ -z "$PATH_ID" ]] && PATH_ID="sh-$(date +%s)" && save_state "path" "$PATH_ID"

    # 保存协议
    save_state "proto" "$protocol"

    cat > "$CONFIG_FILE" <<EOF
{
  "log": { "loglevel": "warning" },
  "inbounds": [{
    "port": $PORT,
    "listen": "127.0.0.1",
    "protocol": "$protocol",
    "settings": {
      "clients": [{ "id": "$UUID", "alterId": 0 }],
      "decryption": "none"
    },
    "streamSettings": {
      "network": "ws",
      "wsSettings": { "path": "/$PATH_ID" }
    }
  }],
  "outbounds": [{ "protocol": "freedom" }]
}
EOF
}

# ---------- Systemd 管理 ----------
install_systemd() {
    local args="$1" # argo arguments
    
    # Xray Service
    cat > /etc/systemd/system/suoha-xray.service <<EOF
[Unit]
Description=Suoha Xray Service
After=network.target

[Service]
ExecStart=$XRAY_BIN run -c $CONFIG_FILE
Restart=always
User=root

[Install]
WantedBy=multi-user.target
EOF

    # Argo Service
    cat > /etc/systemd/system/suoha-argo.service <<EOF
[Unit]
Description=Suoha Argo Tunnel
After=network.target

[Service]
ExecStart=$ARGO_BIN tunnel $args
Restart=always
User=root

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable suoha-xray suoha-argo >/dev/null 2>&1
    systemctl restart suoha-xray suoha-argo
    green "$(t service_installed)"
}

# ---------- 链接生成 (TLS & Non-TLS) ----------
gen_links() {
    local domain=$1
    local remark=$2
    local proto=$(load_state "proto")
    local uuid=$(load_state "uuid")
    local path=$(load_state "path")
    
    # 构造 JSON
    # 1. TLS Link (Standard 443)
    local json_tls
    if [[ "$proto" == "vmess" ]]; then
        json_tls=$(jq -n \
            --arg v "2" --arg ps "${remark}_TLS" --arg add "$domain" --arg port "443" \
            --arg id "$uuid" --arg aid "0" --arg net "ws" --arg type "none" \
            --arg host "$domain" --arg path "/$path" --arg tls "tls" \
            '{v:$v, ps:$ps, add:$add, port:$port, id:$id, aid:$aid, net:$net, type:$type, host:$host, path:$path, tls:$tls}')
        link_tls="vmess://$(echo -n "$json_tls" | base64 -w0)"
    else
        # VLESS TLS
        link_tls="vless://${uuid}@${domain}:443?encryption=none&security=tls&type=ws&host=${domain}&path=%2F${path}#${remark}_TLS"
    fi

    # 2. Non-TLS Link (Port 80 - 仅用于 Cloudflare 允许 HTTP 的情况)
    # 这里的 Non-TLS 其实是客户端不开启 TLS，连接 Cloudflare 的 80 端口，Cloudflare 再回源
    local json_none
    if [[ "$proto" == "vmess" ]]; then
        json_none=$(jq -n \
            --arg v "2" --arg ps "${remark}_NoTLS" --arg add "$domain" --arg port "80" \
            --arg id "$uuid" --arg aid "0" --arg net "ws" --arg type "none" \
            --arg host "$domain" --arg path "/$path" --arg tls "" \
            '{v:$v, ps:$ps, add:$add, port:$port, id:$id, aid:$aid, net:$net, type:$type, host:$host, path:$path, tls:$tls}')
        link_none="vmess://$(echo -n "$json_none" | base64 -w0)"
    else
        # VLESS Non-TLS
        link_none="vless://${uuid}@${domain}:80?encryption=none&security=none&type=ws&host=${domain}&path=%2F${path}#${remark}_NoTLS"
    fi

    # 保存并显示
    cat > "$LINK_FILE" <<EOF
=============================================
节点生成时间: $(date)
ISP Info: $(get_isp)
UUID: $uuid
Path: /$path
Protocol: $proto
=============================================

[1] TLS 节点 (推荐, Port 443):
$link_tls

[2] 非 TLS 节点 (Port 80, 需CF支持):
$link_none

=============================================
EOF
    
    clear
    cat "$LINK_FILE"
    echo ""
    green "$(t links_saved)$LINK_FILE"
}

# ---------- 启动逻辑 ----------
start_quick() {
    local proto=$(load_state "proto")
    [[ -z "$proto" ]] && proto="vmess"
    
    gen_config "$proto"
    
    # 临时隧道不支持 Systemd 保持域名 (因为每次都会变)，所以用 nohup
    # 先停止 Systemd 以防冲突
    systemctl stop suoha-argo suoha-xray 2>/dev/null || true
    pkill -f "$XRAY_BIN" || true
    pkill -f "$ARGO_BIN" || true

    "$XRAY_BIN" run -c "$CONFIG_FILE" >/dev/null 2>&1 &
    "$ARGO_BIN" tunnel --url "http://127.0.0.1:$PORT" --no-autoupdate >"$ARGO_LOG" 2>&1 &

    echo "$(t starting)"
    sleep 5
    
    local try_domain
    for i in {1..10}; do
        try_domain=$(grep -oE "https://[a-zA-Z0-9-]+\.trycloudflare\.com" "$ARGO_LOG" | head -n 1 | sed 's/https:\/\///')
        [[ -n "$try_domain" ]] && break
        sleep 2
    done

    if [[ -z "$try_domain" ]]; then
        red "获取临时域名失败，请检查日志: $ARGO_LOG"
        exit 1
    fi
    
    save_state "domain" "$try_domain"
    save_state "mode" "quick"
    gen_links "$try_domain" "Suoha_Quick"
}

start_fixed() {
    local proto=$(load_state "proto")
    [[ -z "$proto" ]] && proto="vmess"
    
    yellow "$(t tunnel_login)"
    "$ARGO_BIN" tunnel login
    
    read -r -p "$(t input_domain)" full_domain
    if [[ -z "$full_domain" ]]; then red "Empty domain"; exit 1; fi
    
    gen_config "$proto"
    
    local tunnel_name="suoha-fixed"
    "$ARGO_BIN" tunnel create "$tunnel_name" 2>/dev/null || true
    "$ARGO_BIN" tunnel route dns "$tunnel_name" "$full_domain" 2>/dev/null || true
    
    local cred_file
    cred_file=$(find ~/.cloudflared -name "*.json" | xargs grep -l "$tunnel_name" | head -n 1)
    
    cat > "$TUNNEL_CONFIG" <<EOF
tunnel: $tunnel_name
credentials-file: $cred_file
ingress:
  - hostname: $full_domain
    service: http://localhost:$PORT
  - service: http_status:404
EOF

    save_state "domain" "$full_domain"
    save_state "mode" "fixed"
    
    # 使用 Systemd 托管
    install_systemd "--config $TUNNEL_CONFIG run $tunnel_name"
    gen_links "$full_domain" "Suoha_Fixed"
}

cleanup() {
    systemctl stop suoha-xray suoha-argo 2>/dev/null || true
    systemctl disable suoha-xray suoha-argo 2>/dev/null || true
    pkill -f "$XRAY_BIN" || true
    pkill -f "$ARGO_BIN" || true
    rm -f "$BASE_DIR"/*.pid
    green "All services stopped."
}

# ---------- 主菜单 ----------
show_menu() {
    clear
    install_deps
    download_bins
    
    local curr_proto=$(load_state "proto")
    [[ -z "$curr_proto" ]] && curr_proto="vmess"
    
    green "$(t welcome)"
    echo "--------------------------------"
    if pkill -0 -f "$XRAY_BIN" >/dev/null 2>&1; then
        echo -e "$(t menu_title): $(green "$(t status_running)") [$(load_state mode)]"
        echo -e "Domain: $(blue "$(load_state domain)")"
    else
        echo -e "$(t menu_title): $(red "$(t status_stopped)")"
    fi
    echo "--------------------------------"
    echo "1. $(t menu_opt_1)"
    echo "2. $(t menu_opt_2)"
    echo "3. $(t menu_opt_3)"
    echo "4. $(t menu_opt_4)"
    echo "5. $(t menu_opt_5 "$curr_proto")"
    echo "0. $(t menu_exit)"
    echo ""
    read -p "> " choice
    
    case "$choice" in
        1) start_quick ;;
        2) start_fixed ;;
        3) 
           if [[ -f "$LINK_FILE" ]]; then cat "$LINK_FILE"; else red "No links found"; fi 
           read -p "Press Enter..."
           show_menu
           ;;
        4) cleanup; show_menu ;;
        5) 
           if [[ "$curr_proto" == "vmess" ]]; then save_state "proto" "vless"; else save_state "proto" "vmess"; fi
           show_menu
           ;;
        0) exit 0 ;;
        *) show_menu ;;
    esac
}

# 入口
show_menu
